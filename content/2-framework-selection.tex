\chapter{Framework selection}

Selecting the optimal framework for any project can be difficult, with many
parameters and options to consider, and quite often, there are better options
than the most popular. The JavaScript ecosystem is rich in choice, as throughout
the years, many developers and companies have aimed to create packages in their
image. Mainly due to this plethora of choices, there is a need for an overview,
which would present advantages and disadvantages. However, only some frameworks
can be reviewed; therefore, at least essential criteria need to be established. 

The selected packages were selected for their support of TypeScript, with
varying levels of compatibility, which will be shown in further detail later.
Additional criteria considered were popularity and support as separate factors,
leading to the inclusion of widely-used packages with currently limited support
and development and lesser-known packages with solid support. 

\section{Typescript support}
The primary selection criterion for the packages was TypeScript compatibility.
Each package had to have at least a basic functionality working and typed,
requiring only reasonable effort to integrate. The degree of support varies
among the packages, and their level was also measured in comparison, but the
base level was necessary to be considered.

The functionality considered essential is not easy to define either, but as the
level of type support varied, the minimum settled on was package and connection
setup and simple querying. The package had to have connection options typed, at
least for primary usage, as listing all options for all connections is not
necessary for most uses. Querying and updating database records is the most
common activity for which ORMs and connection builders will be used, so the
types they provide are some of the most useful. The result of a simple
non-joined query on one table should be able to return exact and correct types,
and an update of the record should also at least suggest the attributes which
can be changed.

\section{Popularity and Support}
Popularity was inherently a factor in the selection of packages; if the package
was known more, its likelihood of being found was smaller. We researched
popularity in several ways; the primary source was searching by name and keyword
ORM on the npm repository \cite{npmSearchORM}. Secondary sources were articles on
ORM and database access in Node.js \cite{SitePoint_2021}, \cite{Wang_2020}. The npm
repository provides statistics about the packages listed on it, the most
prominent being weekly downloads. The statistic is good for basic orientation
but is not a great indicator of the exact number of users, as users can download
the package multiple times, most packages are cached by third parties, which
automatically download a version when it is released and many more ways, which
skew the number. Additional input for popularity was the number of issues and
stars the project currently holds on GitHub.

Support is a secondary attribute that is highly linked to popularity. Although
all packages reviewed are open-source, only maintainers can merge code into the
main branch or release versions onto the registry. If they are no longer active,
the project effectively stops. While they can be released under a new name if
the licence permits such a thing, no packages missing implementation into the
benchmark have forks that would relieve the issues encountered. High-quality
support is crucial for addressing issues, incorporating new features and
compatibility with changes in underlying technologies.

\section{Implementation criteria}
Although some packages were initially selected for comparison, as previously
mentioned, problems that needed to be more severe were encountered during their
implementation into the included benchmarks. They will still be introduced, and
the issues explained; however, they will only be included in comparisons within
the basic summary.
