\chapter{Introduction}

In the modern world, data have become an essential aspect of almost every field.
From e-commerce to healthcare, education to finance, data is everywhere and
plays a~critical role in decision-making processes. The advent of Web 2.0
\cite{Web2Oreilly}, which brought the concept of user-generated content, was
largely supported by connecting the Web to databases. Social media platforms,
for example, rely heavily on data to provide personalized recommendations,
targeted advertising, and other features that keep users engaged. Even
applications not working with the internet often need significant data storage
and, as a~result, the ability to manage and manipulate data has become a
critical skill for developers and organisations alike.

Relational databases such as SQL Server and PostgreSQL are by far the most
popular type of databases for data storage used in business-level applications.
These databases use the relational data model, which is based on tables with
rows and columns, to store and manipulate data.

Object-oriented programming languages and languages incorporating parts of the
paradigm, such as Java, Python, Ruby, and JavaScript, have gained
popularity \cite{stack-overflow-survey} due to their ability to create complex
software systems that can handle large amounts of data efficiently.
Object-oriented programming (OOP) is a~programming paradigm that represents
concepts as \enquote{objects} that have attributes (data) and behaviours
(methods). This makes it easier to write, maintain, and reuse code, which is
essential when working with large-scale software systems.

Despite the popularity of object-oriented programming languages, there is often
a disparity between OOP languages and the relational data model used by many
databases. OOP languages are designed to work with objects, whereas relational
databases are designed to work with relations. This can make it challenging for
developers to work with databases using OOP languages. 

Object-Relational Mapping (ORM) has become a~popular solution for developers who
need to connect object-oriented programming languages with relational databases
\cite{Torres_Galante_Pimenta_Martins_2017}. ORM allows developers to work with
relational databases using object-oriented programming languages, eliminating
the need to write complex SQL queries. By abstracting away the details of the
underlying database, ORM allows developers to focus on the application logic and
reduces the amount of boilerplate code that needs to be written. This makes it
easier for developers to work with databases and reduces the potential for
errors. 

The thesis aims to conduct a~comprehensive analysis of the most popular ORM
packages and SQL query builders for Typescript. This analysis will provide an
objective measurement of their relative strengths and weaknesses in terms of
functionality, type support, performance, and package quality. Also included are
noncomparative examples of syntax and usage examples of the packages, to
illustrate strengths and weaknesses and to showcase the functionality of the
modules. By evaluating each package's performance in these key areas, the thesis
aims to provide a~comprehensive comparison that will be useful to developers who
are looking for the best ORM or SQL query builder package for their Typescript
project.

While there are existing comparisons, most of them are created from the point of
a biased actor, usually a~competitive or alternative solution developer
\cite{drizzleComparison} \cite{imdbBench}. This thesis aims to provide an
independent view.

% Before we start with the full comparison of ORMs that support TypeScript, we
% must first define what counts as an Object-Relational Mapping Package, what are
% SQL Query Builders, and other technologies and terms used further in this work.
% Then we explain how the packages further analysed were selected and by which
% criteria they are ranked and reviewed.

The thesis is organized into eight comprehensive chapters that guide the reader
through comparing and benchmarking various frameworks. Chapter 1 sets the
foundation by defining the terminology used throughout the thesis and providing
context for each term. Chapter 2 focuses on determining the essential attributes
for a~framework to be considered for inclusion in the comparison. Chapter 3 then
discusses the criteria used to compare and rank the packages, from directly
calculated comparisons to more qualitative aspects like TypeScript support level
and documentation quality.

Chapters 4 through 8 delve into the practical aspects of the thesis, with
Chapter 4 introducing the features of the Cat database, which serves as the
basis for testing the features and performance of the packages. Chapter 5
outlines the design of the benchmark framework and highlights the crucial
features for implementation. Chapter 6 covers the actualization of this design
into a~functional benchmarking tool. Chapter 7 presents an in-depth analysis of
individual packages, noting any problems or interesting findings encountered
during the implementation of testing tasks. Finally, Chapter 8 synthesizes the
results of the benchmarking process, comparing and contextualizing the findings
from both flexibility and performance testing.