\section{MikroORM}

MikroORM, a~project developed by Martin AdÃ¡mek, has emerged as an ORM solution
that offers both versatility and ease of use. With a~focus on implicit
transactions using the Unit of Work pattern, MikroORM offers native support for
NoSQL databases, specifically MongoDB, alongside support for traditional
relational databases such as MySQL, MariaDB, PostgreSQL, and SQLite
\cite{mikroORMWeb}. At the time of writing, MikroORM has garnered decent
attention, with 189,128 weekly downloads and 5,777 stars on GitHub
\cite{mikroORMGitHub} \cite{mikroORMNpm}.

The internal architecture of MikroORM for relational databases is powered by
Knex, a~popular SQL query builder library, which allows developers to access the
underlying query builder with type support provided by MikroORM's definitions.
Users can therefore utilize the full power of knex while benefiting from the
additional features and abstractions MikroORM provides. Database models are
represented using classes with decorators, making creating relationships between
entities intuitive through explicit \texttt{@OneToOne}, \texttt{@OneToMany}, and
\texttt{@ManyToMany} decorators that translate seamlessly from the conceptual
schema of the database as represented in \autoref{lst:mikroORMEntity}.
Furthermore, MikroORM offers an EntityGenerator package that allows developers
to generate these definitions based on an existing database schema
automatically.

\begin{listing}
    \caption{Cat color entity represented in MikroORM schema}
    \label{lst:mikroORMEntity}
    \begin{minted}{typescript}
@Entity()
export class CatColor {
  @PrimaryKey()
  id!: number

  @Property({ length: 256 })
  colorName!: string

  @OneToMany({ entity: () => Cat, mappedBy: 'catColor' })
  cats = new Collection<Cat>(this)

  @OneToOne({ entity: () => ColorHex, mappedBy: 'id' })
  colorHex?: ColorHex
}
    \end{minted}
    \vspace{-\baselineskip}
\end{listing}

Regarding TypeScript compatibility, MikroORM supports compiled TypeScript and
native TypeScript execution using ts-node. However, it does not support
alternative runtimes like Deno due to various limitations, including
dependencies \cite{mikroORMDeno}. Speaking of dependencies, MikroORM relies on
several well-known JavaScript packages for parsing and metadata reflection,
which the package utilizes for establishing relationships and maintaining
context.

The documentation for MikroORM is comprehensive, providing all the necessary
information for developers to utilize the package effectively
\cite{mikroORMDocs}. While the types do not direct link to the documentation,
they include basic descriptions of the methods, which aids in understanding
their usage. MikroORM also offers support for migrations and seeding, with
migrations generated by analysing the differences between the database schema
and the schema defined within MikroORM. It also supports read replica
connections using random selection for which instance to use for the query.

\subsection*{Performance in benchmarks}

The Mikro ORM package distinguished itself in performance benchmarks primarily
due to its unique features. In addition to standard query handling, the package
facilitates field matching using JavaScript native regular expressions, which
are subsequently parsed and translated into SQL queries. Another remarkable
result was observed in the JSONColumn latency test, where MikroORM significantly
outpaced even the pgTyped package. This achievement is not attributed to
superior database connection performance but to the package's Entity Manager.
This internal cache/repository is designed for particular contexts. It caches
the current state based on the object's primary key values, enabling rapid data
retrieval from application memory rather than querying the database
\cite{mikroORM-EM}. However, this approach may introduce inconsistencies,
prompting MikroORM to implement optimistic locking for fields potentially
impacted by such issues.

Relations are incorporated using the \texttt{populate} option, which permits dot
notation for further related entities and filtering. While not strictly typed,
simple nested objects have enough type support to provide essential information
for query composition and function as anticipated. The results are well-typed,
although BigInteger and Decimal types are returned as strings. Transaction
support with a~direct control sequence API is also implemented. For instances
where the integrated interface lacks flexibility, pre-typed Knex.js instance is
accessible for most queries.

Entities in MikroORM are straightforward to implement, although documentation
for their use with complex decomposition tables is limited and has to be
implemented through a~standard relations between three tables. a~minor issue
arose due to an undocumented difference between the \texttt{columnType} and
\texttt{type} options; however, the package's developer promptly addressed the
concern. Overall, MikroORM offers a~compelling balance of features and
performance, making it a~viable choice for various applications.
